\section{医学影像处理中的预处理}
\label{sec:imaging_preprocessing}

\subsection{曲率各向异性扩散滤波}
\label{subsec:imaging_edge_potential}

对图像的平滑处理是一项必须的环节，该环节的目的在于除去在医学模态获取原始图像序列的过程当中所引入的噪声像素，这一现象是不可避免的。
在平滑处理过程当中，目标（此处指主动脉）的原始边缘信息应当得到尽可能完整地保护。
基于这些考虑，我们选择使用一种具有可变通透性的水平集曲率方法\cite{Whitaker2001}来完成这一环节的处理工作。
该方法长于在图像平滑的过程中增强和保护边缘信息，且对边缘对比度变化具有很好的鲁棒性。
该方法可以通过所谓的“改进型曲率扩散方程”（Modified Curvature Diffusion Equation，MCDE）来表达：
\begin{equation}
\label{eqn:imaging_MCDE}
I_t = |\nabla I| \nabla \cdot c(|\nabla I|) \frac{\nabla I}{|\nabla I|},
\end{equation}
其中，$I = I(x, y, 0)$表示输入图像，
$I_t(\cdot) = I(x, y, t)$表示图像像素关于时间$t$的偏导数，
$c$是通透性函数：$c(|\nabla I|) = k^2/(k^2 + |\nabla I|^2)$，
边界的对比度将会对图像的平滑显著的影响，它由参数$k$所决定。

\subsection{基于Gaussian核的梯度幅值滤波}

由于即将生成的特征图像是随后进行的活动轮廓演进的必须信息，因此对图像像素的梯度计算即在此完成平滑处理后的图像上进行。
这一环节的目的是探测目标的边缘。
图像像素的梯度计算基本原理可表述如下\footnote{详见：\url{http://math.nist.gov/mcsd/savg/software/filters/gradient/}}：
\begin{equation}
\label{eqn:imaging_gaussian}
I_{grad} = \exp(-|(\nabla \ast G) \cdot I_t|),
\end{equation}
其中，$I_{grad}$表示图像中某像素点的梯度的幅值，
$\nabla \ast G$代表对高斯算子进行一阶求导运算。

\subsection{非线性像素亮度映射}
\label{subsec:imaging_sigmoid}

随后，上述计算所得的梯度幅值图像将通过一个非线性关系映射生成所需的特征图像，本文中，我们采用了S型函数\footnote{详见：\url{http://en.wikipedia.org/wiki/Sigmoid_function}}（见图\ref{fig:imaging_sigmoid}）：
\begin{equation}
\label{eqn:imaging_sigmoid}
I_{\sigma} = (I_{max} - I_{min}) \cdot \frac{1}{1 + \exp\left(-\frac{I_{grad} - n}{m}\right)} + I_{min},
\end{equation}
其中，$I_{\sigma}$表示输出图像的像素亮度，
$I_{max}$与$I_{min}$分别代表输出像素亮度的最大值和最小值，
$m$是一个常量，它控制输入图像中参与映射的像素亮度的区间，
$n$则是一个确定该区间中心点的位置的常量。
此映射的结果取决于上述参数的选择。
\begin{figure}[t]
\centering
\input{FigureSrc/imaging/sigmoid}
\caption[用于非线性像素映射的S函数]{用于非线性像素映射的S函数。}
\label{fig:imaging_sigmoid}
\end{figure}
\begin{figure}[t]
\centering
\input{FigureSrc/imaging/sigmoid_window_width}
\caption[S函数的参数$m$与窗宽之间的关系]{S函数的参数$m$与窗宽之间的关系：$m = 4$的曲线（青色）具有比$m = -2$的曲线（红色）以及$m = 2$的曲线（绿色）更宽的映射区间。参数$m$的负号表明该S型函数引入了取反作用。}%
\label{fig:imaging_sigmoid_width}
\end{figure}
\begin{figure}[t]
\centering
\input{FigureSrc/imaging/sigmoid_center_location}
\caption[S函数的参数$n$与窗宽之间的关系]{S函数的参数$n$与窗宽之间的关系：当$n < 0$时，曲线左移（如：绿色的曲线）；而当$n > 0$时，曲线右移（如：青色的曲线）。$n$的绝对值决定S型函数几何中心与原点的横向距离。}%
\label{fig:imaging_sigmoid_center}
\end{figure}

由式(\ref{eqn:imaging_sigmoid})定义的S型函数具有四个参数：用于控制窗宽的$m$，控制窗中心位置的$n$，以及确定输出图像中像素亮度极值的$\alpha$（极小值）和$\beta$（极大值）。
图\ref{fig:imaging_sigmoid_width}显示参数$m$如何控制S型函数的窗宽。
参数$m$的值越大，窗宽越宽；反之，则窗宽越窄。
而负的$m$则意味着由其确定的S型函数对输入图像中的像素强度值具有取反作用。
图\ref{fig:imaging_sigmoid_center}显示参数$n$如何控制S型函数几何中心相对于坐标原点的横向距离。
参数$n$的绝对值越大，则由其确定的S型函数的几何中心相对于坐标原点的横线距离就越大（即：几何中心离坐标原点越远）。
正的$n$说明S型函数向右平移；反之，则说明S型函数向左平移。
在对梯度图像进行转换以生成特征图像的时候，参数$m$和$n$的选取是十分重要的。
它们的取值取决于梯度图像中像素亮度的极值。
在本文的实验中，我们的经验是：$m < 0$，$n > 0$，$n > |m|$。
而鉴于我们的应用需要，通常把$\alpha$设定为$0$，而把$\beta$设定为$255$。

\subsection{阈值滤波}
\label{subsec:imaging_thresholding}

在平滑处理后，我们利用设置恰当的阈值滤波来去除图像中非血管部分。
阈值滤波的函数\footnote{阈值滤波与二值阈值滤波简介：\url{http://docs.opencv.org/doc/tutorials/imgproc/threshold/threshold.html}}可表示如下：
\begin{equation}
\label{eqn:imaging_threshold}
I_{\text{output}} =
\begin{cases}
I_{\text{input}}, & \text{TH}_{\text{lower}} \le I_{\text{input}} \le \text{TH}_{\text{upper}}, \\%
0,   & \text{otherwise}.
\end{cases}
\end{equation}
其中， $\text{TH}_{\text{lower}}$与$\text{TH}_{\text{upper}}$分别表示阈值的上下限，而$I_{\text{input}}$与$I_{\text{output}}$则分别表示输入和输出的像素强度。
% 上述函数可表示为图\ref{fig:imaging_threshold_function}。
% \begin{figure}[t]
% \centering
% \input{FigureSrc/imaging/threshold}
% \caption[阈值函数]{阈值函数}
% \label{fig:imaging_threshold_function}
% \end{figure}

\subsection{二值阈值滤波}
\label{subsec:imaging_binary}

在平滑处理后，我们利用设置恰当的阈值滤波来去除图像中非血管部分。
阈值滤波的函数可表示如下：
\begin{equation}
\label{eqn:imaging_threshold}
I_{\text{output}} =
\begin{cases}
255, & \text{TH}_{\text{lower}} \le I_{\text{input}} \le \text{TH}_{\text{upper}}, \\%
0,   & \text{otherwise}.
\end{cases}
\end{equation}
其中， $\text{TH}_{\text{lower}}$与$\text{TH}_{\text{upper}}$分别表示阈值的上下限，而$I_{\text{input}}$与$I_{\text{output}}$则分别表示输入和输出的像素强度。
上述函数可表示为图\ref{fig:imaging_threshold_function}。
\begin{figure}[t]
\centering
\input{FigureSrc/imaging/binary_threshold}
\caption[二值阈值函数]{二值阈值函数}
\label{fig:imaging_threshold_function}
\end{figure}